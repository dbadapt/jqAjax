--- jQuery_ajax_only.js	2014-02-10 04:28:49.010563900 -0600
+++ jqAjax.js	2014-02-10 04:28:49.264953800 -0600
@@ -1,3 +1,5 @@
+// NOTE: jQuery references have been changed to jqAjax to avoid conflicts with existing configurations.
+
 /*!
  * jQuery JavaScript Library v@VERSION
  * http://jquery.com/
@@ -13,8 +15,8 @@
  */
 (function( window, undefined ) {
 var
-	// A central reference to the root jQuery(document)
-	rootjQuery,
+	// A central reference to the root jqAjax(document)
+	rootjqAjax,
 
 	// The deferred used on DOM ready
 	readyList,
@@ -24,11 +26,11 @@
 	location = window.location,
 	navigator = window.navigator,
 
-	// Map over jQuery in case of overwrite
-	_jQuery = window.jQuery,
+	// Map over jqAjax in case of overwrite
+	_jqAjax = window.jqAjax,
 
 	// Map over the $ in case of overwrite
-	_$ = window.$,
+//	_$ = window.$,
 
 	// Save a reference to some core methods
 	core_push = Array.prototype.push,
@@ -38,10 +40,10 @@
 	core_hasOwn = Object.prototype.hasOwnProperty,
 	core_trim = String.prototype.trim,
 
-	// Define a local copy of jQuery
-	jQuery = function( selector, context ) {
-		// The jQuery object is actually just the init constructor 'enhanced'
-		return new jQuery.fn.init( selector, context, rootjQuery );
+	// Define a local copy of jqAjax
+	jqAjax = function( selector, context ) {
+		// The jqAjax object is actually just the init constructor 'enhanced'
+		return new jqAjax.fn.init( selector, context, rootjqAjax );
 	},
 
 	// Used for matching numbers
@@ -71,7 +73,7 @@
 	rmsPrefix = /^-ms-/,
 	rdashAlpha = /-([\da-z])/gi,
 
-	// Used by jQuery.camelCase as callback to replace()
+	// Used by jqAjax.camelCase as callback to replace()
 	fcamelCase = function( all, letter ) {
 		return ( letter + "" ).toUpperCase();
 	},
@@ -80,21 +82,21 @@
 	DOMContentLoaded = function() {
 		if ( document.addEventListener ) {
 			document.removeEventListener( "DOMContentLoaded", DOMContentLoaded, false );
-			jQuery.ready();
+			jqAjax.ready();
 		} else if ( document.readyState === "complete" ) {
 			// we're here because readyState === "complete" in oldIE
 			// which is good enough for us to call the dom ready!
 			document.detachEvent( "onreadystatechange", DOMContentLoaded );
-			jQuery.ready();
+			jqAjax.ready();
 		}
 	},
 
 	// [[Class]] -> type pairs
 	class2type = {};
 
-jQuery.fn = jQuery.prototype = {
-	constructor: jQuery,
-	init: function( selector, context, rootjQuery ) {
+jqAjax.fn = jqAjax.prototype = {
+	constructor: jqAjax,
+	init: function( selector, context, rootjqAjax ) {
 		var match, elem, ret, doc;
 
 		// Handle $(""), $(null), $(undefined), $(false)
@@ -124,16 +126,16 @@
 
 				// HANDLE: $(html) -> $(array)
 				if ( match[1] ) {
-					context = context instanceof jQuery ? context[0] : context;
+					context = context instanceof jqAjax ? context[0] : context;
 					doc = ( context && context.nodeType ? context.ownerDocument || context : document );
 
 					// scripts is true for back-compat
-					selector = jQuery.parseHTML( match[1], doc, true );
-					if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
+					selector = jqAjax.parseHTML( match[1], doc, true );
+					if ( rsingleTag.test( match[1] ) && jqAjax.isPlainObject( context ) ) {
 						this.attr.call( selector, context, true );
 					}
 
-					return jQuery.merge( this, selector );
+					return jqAjax.merge( this, selector );
 
 				// HANDLE: $(#id)
 				} else {
@@ -145,10 +147,10 @@
 						// Handle the case where IE and Opera return items
 						// by name instead of ID
 						if ( elem.id !== match[2] ) {
-							return rootjQuery.find( selector );
+							return rootjqAjax.find( selector );
 						}
 
-						// Otherwise, we inject the element directly into the jQuery object
+						// Otherwise, we inject the element directly into the jqAjax object
 						this.length = 1;
 						this[0] = elem;
 					}
@@ -159,8 +161,8 @@
 				}
 
 			// HANDLE: $(expr, $(...))
-			} else if ( !context || context.jquery ) {
-				return ( context || rootjQuery ).find( selector );
+			} else if ( !context || context.jqajax ) {
+				return ( context || rootjqAjax ).find( selector );
 
 			// HANDLE: $(expr, context)
 			// (which is just equivalent to: $(context).find(expr)
@@ -170,8 +172,8 @@
 
 		// HANDLE: $(function)
 		// Shortcut for document ready
-		} else if ( jQuery.isFunction( selector ) ) {
-			return rootjQuery.ready( selector );
+		} else if ( jqAjax.isFunction( selector ) ) {
+			return rootjqAjax.ready( selector );
 		}
 
 		if ( selector.selector !== undefined ) {
@@ -179,16 +181,16 @@
 			this.context = selector.context;
 		}
 
-		return jQuery.makeArray( selector, this );
+		return jqAjax.makeArray( selector, this );
 	},
 
 	// Start with an empty selector
 	selector: "",
 
-	// The current version of jQuery being used
-	jquery: "@VERSION",
+	// The current version of jqAjax being used
+	jqajax: "@VERSION",
 
-	// The default length of a jQuery object is 0
+	// The default length of a jqAjax object is 0
 	length: 0,
 
 	// The number of elements contained in the matched element set
@@ -216,8 +218,8 @@
 	// (returning the new matched element set)
 	pushStack: function( elems, name, selector ) {
 
-		// Build a new jQuery matched element set
-		var ret = jQuery.merge( this.constructor(), elems );
+		// Build a new jqAjax matched element set
+		var ret = jqAjax.merge( this.constructor(), elems );
 
 		// Add the old object onto the stack (as a reference)
 		ret.prevObject = this;
@@ -238,12 +240,12 @@
 	// (You can seed the arguments with an array of args, but this is
 	// only used internally.)
 	each: function( callback, args ) {
-		return jQuery.each( this, callback, args );
+		return jqAjax.each( this, callback, args );
 	},
 
 	ready: function( fn ) {
 		// Add the callback
-		jQuery.ready.promise().done( fn );
+		jqAjax.ready.promise().done( fn );
 
 		return this;
 	},
@@ -269,7 +271,7 @@
 	},
 
 	map: function( callback ) {
-		return this.pushStack( jQuery.map(this, function( elem, i ) {
+		return this.pushStack( jqAjax.map(this, function( elem, i ) {
 			return callback.call( elem, i, elem );
 		}));
 	},
@@ -279,16 +281,16 @@
 	},
 
 	// For internal use only.
-	// Behaves like an Array's method, not like a jQuery method.
+	// Behaves like an Array's method, not like a jqAjax method.
 	push: core_push,
 	sort: [].sort,
 	splice: [].splice
 };
 
-// Give the init function the jQuery prototype for later instantiation
-jQuery.fn.init.prototype = jQuery.fn;
+// Give the init function the jqAjax prototype for later instantiation
+jqAjax.fn.init.prototype = jqAjax.fn;
 
-jQuery.extend = jQuery.fn.extend = function() {
+jqAjax.extend = jqAjax.fn.extend = function() {
 	var options, name, src, copy, copyIsArray, clone,
 		target = arguments[0] || {},
 		i = 1,
@@ -304,11 +306,11 @@
 	}
 
 	// Handle case when target is a string or something (possible in deep copy)
-	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
+	if ( typeof target !== "object" && !jqAjax.isFunction(target) ) {
 		target = {};
 	}
 
-	// extend jQuery itself if only one argument is passed
+	// extend jqAjax itself if only one argument is passed
 	if ( length === i ) {
 		target = this;
 		--i;
@@ -328,17 +330,17 @@
 				}
 
 				// Recurse if we're merging plain objects or arrays
-				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
+				if ( deep && copy && ( jqAjax.isPlainObject(copy) || (copyIsArray = jqAjax.isArray(copy)) ) ) {
 					if ( copyIsArray ) {
 						copyIsArray = false;
-						clone = src && jQuery.isArray(src) ? src : [];
+						clone = src && jqAjax.isArray(src) ? src : [];
 
 					} else {
-						clone = src && jQuery.isPlainObject(src) ? src : {};
+						clone = src && jqAjax.isPlainObject(src) ? src : {};
 					}
 
 					// Never move original objects, clone them
-					target[ name ] = jQuery.extend( deep, clone, copy );
+					target[ name ] = jqAjax.extend( deep, clone, copy );
 
 				// Don't bring in undefined values
 				} else if ( copy !== undefined ) {
@@ -352,18 +354,7 @@
 	return target;
 };
 
-jQuery.extend({
-	noConflict: function( deep ) {
-		if ( window.$ === jQuery ) {
-			window.$ = _$;
-		}
-
-		if ( deep && window.jQuery === jQuery ) {
-			window.jQuery = _jQuery;
-		}
-
-		return jQuery;
-	},
+jqAjax.extend({
 
 	// Is the DOM ready to be used? Set to true once it occurs.
 	isReady: false,
@@ -375,9 +366,9 @@
 	// Hold (or release) the ready event
 	holdReady: function( hold ) {
 		if ( hold ) {
-			jQuery.readyWait++;
+			jqAjax.readyWait++;
 		} else {
-			jQuery.ready( true );
+			jqAjax.ready( true );
 		}
 	},
 
@@ -385,29 +376,29 @@
 	ready: function( wait ) {
 
 		// Abort if there are pending holds or we're already ready
-		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
+		if ( wait === true ? --jqAjax.readyWait : jqAjax.isReady ) {
 			return;
 		}
 
 		// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
 		if ( !document.body ) {
-			return setTimeout( jQuery.ready, 1 );
+			return setTimeout( jqAjax.ready, 1 );
 		}
 
 		// Remember that the DOM is ready
-		jQuery.isReady = true;
+		jqAjax.isReady = true;
 
 		// If a normal DOM Ready event fired, decrement, and wait if need be
-		if ( wait !== true && --jQuery.readyWait > 0 ) {
+		if ( wait !== true && --jqAjax.readyWait > 0 ) {
 			return;
 		}
 
 		// If there are functions bound, to execute
-		readyList.resolveWith( document, [ jQuery ] );
+		readyList.resolveWith( document, [ jqAjax ] );
 
 		// Trigger any bound ready events
-		if ( jQuery.fn.trigger ) {
-			jQuery( document ).trigger("ready").off("ready");
+		if ( jqAjax.fn.trigger ) {
+			jqAjax( document ).trigger("ready").off("ready");
 		}
 	},
 
@@ -415,11 +406,11 @@
 	// Since version 1.3, DOM methods and functions like alert
 	// aren't supported. They return false on IE (#2968).
 	isFunction: function( obj ) {
-		return jQuery.type(obj) === "function";
+		return jqAjax.type(obj) === "function";
 	},
 
 	isArray: Array.isArray || function( obj ) {
-		return jQuery.type(obj) === "array";
+		return jqAjax.type(obj) === "array";
 	},
 
 	isWindow: function( obj ) {
@@ -440,7 +431,7 @@
 		// Must be an Object.
 		// Because of IE, we also have to check the presence of the constructor property.
 		// Make sure that DOM nodes and window objects don't pass through, as well
-		if ( !obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
+		if ( !obj || jqAjax.type(obj) !== "object" || obj.nodeType || jqAjax.isWindow( obj ) ) {
 			return false;
 		}
 
@@ -496,9 +487,9 @@
 			return [ context.createElement( parsed[1] ) ];
 		}
 
-		parsed = jQuery.buildFragment( [ data ], context, scripts ? null : [] );
-		return jQuery.merge( [],
-			(parsed.cacheable ? jQuery.clone( parsed.fragment ) : parsed.fragment).childNodes );
+		parsed = jqAjax.buildFragment( [ data ], context, scripts ? null : [] );
+		return jqAjax.merge( [],
+			(parsed.cacheable ? jqAjax.clone( parsed.fragment ) : parsed.fragment).childNodes );
 	},
 
 	parseJSON: function( data ) {
@@ -507,7 +498,7 @@
 		}
 
 		// Make sure leading/trailing whitespace is removed (IE can't handle it)
-		data = jQuery.trim( data );
+		data = jqAjax.trim( data );
 
 		// Attempt to parse using the native JSON parser first
 		if ( window.JSON && window.JSON.parse ) {
@@ -523,7 +514,7 @@
 			return ( new Function( "return " + data ) )();
 
 		}
-		jQuery.error( "Invalid JSON: " + data );
+		jqAjax.error( "Invalid JSON: " + data );
 	},
 
 	// Cross-browser xml parsing
@@ -545,7 +536,7 @@
 			xml = undefined;
 		}
 		if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {
-			jQuery.error( "Invalid XML: " + data );
+			jqAjax.error( "Invalid XML: " + data );
 		}
 		return xml;
 	},
@@ -559,7 +550,7 @@
 		if ( data && core_rnotwhite.test( data ) ) {
 			// We use execScript on Internet Explorer
 			// We use an anonymous function so that context is window
-			// rather than jQuery in Firefox
+			// rather than jqAjax in Firefox
 			( window.execScript || function( data ) {
 				window[ "eval" ].call( window, data );
 			} )( data );
@@ -581,7 +572,7 @@
 		var name,
 			i = 0,
 			length = obj.length,
-			isObj = length === undefined || jQuery.isFunction( obj );
+			isObj = length === undefined || jqAjax.isFunction( obj );
 
 		if ( args ) {
 			if ( isObj ) {
@@ -641,12 +632,12 @@
 		if ( arr != null ) {
 			// The window, strings (and functions) also have 'length'
 			// Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930
-			type = jQuery.type( arr );
+			type = jqAjax.type( arr );
 
-			if ( arr.length == null || type === "string" || type === "function" || type === "regexp" || jQuery.isWindow( arr ) ) {
+			if ( arr.length == null || type === "string" || type === "function" || type === "regexp" || jqAjax.isWindow( arr ) ) {
 				core_push.call( ret, arr );
 			} else {
-				jQuery.merge( ret, arr );
+				jqAjax.merge( ret, arr );
 			}
 		}
 
@@ -721,8 +712,8 @@
 			ret = [],
 			i = 0,
 			length = elems.length,
-			// jquery objects are treated as arrays
-			isArray = elems instanceof jQuery || length !== undefined && typeof length === "number" && ( ( length > 0 && elems[ 0 ] && elems[ length -1 ] ) || length === 0 || jQuery.isArray( elems ) ) ;
+			// jqajax objects are treated as arrays
+			isArray = elems instanceof jqAjax || length !== undefined && typeof length === "number" && ( ( length > 0 && elems[ 0 ] && elems[ length -1 ] ) || length === 0 || jqAjax.isArray( elems ) ) ;
 
 		// Go through the array, translating each of the items to their
 		if ( isArray ) {
@@ -765,7 +756,7 @@
 
 		// Quick check to determine if target is callable, in the spec
 		// this throws a TypeError, but we will just return undefined.
-		if ( !jQuery.isFunction( fn ) ) {
+		if ( !jqAjax.isFunction( fn ) ) {
 			return undefined;
 		}
 
@@ -776,7 +767,7 @@
 		};
 
 		// Set the guid of unique handler to the same of original handler, so it can be removed
-		proxy.guid = fn.guid = fn.guid || jQuery.guid++;
+		proxy.guid = fn.guid = fn.guid || jqAjax.guid++;
 
 		return proxy;
 	},
@@ -792,21 +783,21 @@
 		// Sets many values
 		if ( key && typeof key === "object" ) {
 			for ( i in key ) {
-				jQuery.access( elems, fn, i, key[i], 1, emptyGet, value );
+				jqAjax.access( elems, fn, i, key[i], 1, emptyGet, value );
 			}
 			chainable = 1;
 
 		// Sets one value
 		} else if ( value !== undefined ) {
 			// Optionally, function values get executed if exec is true
-			exec = pass === undefined && jQuery.isFunction( value );
+			exec = pass === undefined && jqAjax.isFunction( value );
 
 			if ( bulk ) {
 				// Bulk operations only iterate when executing function values
 				if ( exec ) {
 					exec = fn;
 					fn = function( elem, key, value ) {
-						return exec.call( jQuery( elem ), value );
+						return exec.call( jqAjax( elem ), value );
 					};
 
 				// Otherwise they run against the entire set
@@ -839,17 +830,17 @@
 	}
 });
 
-jQuery.ready.promise = function( obj ) {
+jqAjax.ready.promise = function( obj ) {
 	if ( !readyList ) {
 
-		readyList = jQuery.Deferred();
+		readyList = jqAjax.Deferred();
 
 		// Catch cases where $(document).ready() is called after the browser event has already occurred.
 		// we once tried to use readyState "interactive" here, but it caused issues like the one
-		// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
+		// discovered by ChrisS here: http://bugs.jqajax.com/ticket/12282#comment:15
 		if ( document.readyState === "complete" ) {
 			// Handle it asynchronously to allow scripts the opportunity to delay ready
-			setTimeout( jQuery.ready, 1 );
+			setTimeout( jqAjax.ready, 1 );
 
 		// Standards-based browsers support DOMContentLoaded
 		} else if ( document.addEventListener ) {
@@ -857,7 +848,7 @@
 			document.addEventListener( "DOMContentLoaded", DOMContentLoaded, false );
 
 			// A fallback to window.onload, that will always work
-			window.addEventListener( "load", jQuery.ready, false );
+			window.addEventListener( "load", jqAjax.ready, false );
 
 		// If IE event model is used
 		} else {
@@ -865,7 +856,7 @@
 			document.attachEvent( "onreadystatechange", DOMContentLoaded );
 
 			// A fallback to window.onload, that will always work
-			window.attachEvent( "onload", jQuery.ready );
+			window.attachEvent( "onload", jqAjax.ready );
 
 			// If IE and not a frame
 			// continually check to see if the document is ready
@@ -877,7 +868,7 @@
 
 			if ( top && top.doScroll ) {
 				(function doScrollCheck() {
-					if ( !jQuery.isReady ) {
+					if ( !jqAjax.isReady ) {
 
 						try {
 							// Use the trick by Diego Perini
@@ -888,7 +879,7 @@
 						}
 
 						// and execute any waiting functions
-						jQuery.ready();
+						jqAjax.ready();
 					}
 				})();
 			}
@@ -898,19 +889,19 @@
 };
 
 // Populate the class2type map
-jQuery.each("Boolean Number String Function Array Date RegExp Object".split(" "), function(i, name) {
+jqAjax.each("Boolean Number String Function Array Date RegExp Object".split(" "), function(i, name) {
 	class2type[ "[object " + name + "]" ] = name.toLowerCase();
 });
 
-// All jQuery objects should point back to these
-rootjQuery = jQuery(document);
+// All jqAjax objects should point back to these
+rootjqAjax = jqAjax(document);
 // String to Object options format cache
 var optionsCache = {};
 
 // Convert String-formatted options into Object-formatted ones and store in cache
 function createOptions( options ) {
 	var object = optionsCache[ options ] = {};
-	jQuery.each( options.split( core_rspace ), function( _, flag ) {
+	jqAjax.each( options.split( core_rspace ), function( _, flag ) {
 		object[ flag ] = true;
 	});
 	return object;
@@ -938,13 +929,13 @@
  *	stopOnFalse:	interrupt callings when a callback returns false
  *
  */
-jQuery.Callbacks = function( options ) {
+jqAjax.Callbacks = function( options ) {
 
 	// Convert options from String-formatted to Object-formatted if needed
 	// (we check in cache first)
 	options = typeof options === "string" ?
 		( optionsCache[ options ] || createOptions( options ) ) :
-		jQuery.extend( {}, options );
+		jqAjax.extend( {}, options );
 
 	var // Last fire value (for non-forgettable lists)
 		memory,
@@ -997,8 +988,8 @@
 					// First, we save the current length
 					var start = list.length;
 					(function add( args ) {
-						jQuery.each( args, function( _, arg ) {
-							var type = jQuery.type( arg );
+						jqAjax.each( args, function( _, arg ) {
+							var type = jqAjax.type( arg );
 							if ( type === "function" ) {
 								if ( !options.unique || !self.has( arg ) ) {
 									list.push( arg );
@@ -1025,9 +1016,9 @@
 			// Remove a callback from the list
 			remove: function() {
 				if ( list ) {
-					jQuery.each( arguments, function( _, arg ) {
+					jqAjax.each( arguments, function( _, arg ) {
 						var index;
-						while( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
+						while( ( index = jqAjax.inArray( arg, list, index ) ) > -1 ) {
 							list.splice( index, 1 );
 							// Handle firing indexes
 							if ( firing ) {
@@ -1045,7 +1036,7 @@
 			},
 			// Control if a given callback is in the list
 			has: function( fn ) {
-				return jQuery.inArray( fn, list ) > -1;
+				return jqAjax.inArray( fn, list ) > -1;
 			},
 			// Remove all callbacks from the list
 			empty: function() {
@@ -1099,14 +1090,14 @@
 
 	return self;
 };
-jQuery.extend({
+jqAjax.extend({
 
 	Deferred: function( func ) {
 		var tuples = [
 				// action, add listener, listener list, final state
-				[ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
-				[ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
-				[ "notify", "progress", jQuery.Callbacks("memory") ]
+				[ "resolve", "done", jqAjax.Callbacks("once memory"), "resolved" ],
+				[ "reject", "fail", jqAjax.Callbacks("once memory"), "rejected" ],
+				[ "notify", "progress", jqAjax.Callbacks("memory") ]
 			],
 			state = "pending",
 			promise = {
@@ -1119,15 +1110,15 @@
 				},
 				then: function( /* fnDone, fnFail, fnProgress */ ) {
 					var fns = arguments;
-					return jQuery.Deferred(function( newDefer ) {
-						jQuery.each( tuples, function( i, tuple ) {
+					return jqAjax.Deferred(function( newDefer ) {
+						jqAjax.each( tuples, function( i, tuple ) {
 							var action = tuple[ 0 ],
 								fn = fns[ i ];
 							// deferred[ done | fail | progress ] for forwarding actions to newDefer
-							deferred[ tuple[1] ]( jQuery.isFunction( fn ) ?
+							deferred[ tuple[1] ]( jqAjax.isFunction( fn ) ?
 								function() {
 									var returned = fn.apply( this, arguments );
-									if ( returned && jQuery.isFunction( returned.promise ) ) {
+									if ( returned && jqAjax.isFunction( returned.promise ) ) {
 										returned.promise()
 											.done( newDefer.resolve )
 											.fail( newDefer.reject )
@@ -1145,7 +1136,7 @@
 				// Get a promise for this deferred
 				// If obj is provided, the promise aspect is added to the object
 				promise: function( obj ) {
-					return obj != null ? jQuery.extend( obj, promise ) : promise;
+					return obj != null ? jqAjax.extend( obj, promise ) : promise;
 				}
 			},
 			deferred = {};
@@ -1154,7 +1145,7 @@
 		promise.pipe = promise.then;
 
 		// Add list-specific methods
-		jQuery.each( tuples, function( i, tuple ) {
+		jqAjax.each( tuples, function( i, tuple ) {
 			var list = tuple[ 2 ],
 				stateString = tuple[ 3 ];
 
@@ -1195,10 +1186,10 @@
 			length = resolveValues.length,
 
 			// the count of uncompleted subordinates
-			remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,
+			remaining = length !== 1 || ( subordinate && jqAjax.isFunction( subordinate.promise ) ) ? length : 0,
 
 			// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
-			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),
+			deferred = remaining === 1 ? subordinate : jqAjax.Deferred(),
 
 			// Update function for both resolve and progress values
 			updateFunc = function( i, contexts, values ) {
@@ -1221,7 +1212,7 @@
 			progressContexts = new Array( length );
 			resolveContexts = new Array( length );
 			for ( ; i < length; i++ ) {
-				if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
+				if ( resolveValues[ i ] && jqAjax.isFunction( resolveValues[ i ].promise ) ) {
 					resolveValues[ i ].promise()
 						.done( updateFunc( i, resolveContexts, resolveValues ) )
 						.fail( deferred.reject )
@@ -1240,7 +1231,7 @@
 		return deferred.promise();
 	}
 });
-jQuery.support = (function() {
+jqAjax.support = (function() {
 
 	var support,
 		all,
@@ -1320,7 +1311,7 @@
 		// Where outerHTML is undefined, this still works
 		html5Clone: document.createElement("nav").cloneNode( true ).outerHTML !== "<:nav></:nav>",
 
-		// jQuery.support.boxModel DEPRECATED in 1.8 since we don't support Quirks Mode
+		// jqAjax.support.boxModel DEPRECATED in 1.8 since we don't support Quirks Mode
 		boxModel: ( document.compatMode === "CSS1Compat" ),
 
 		// Will be defined later
@@ -1412,7 +1403,7 @@
 	}
 
 	// Run tests that need a body at doc ready
-	jQuery(function() {
+	jqAjax(function() {
 		var container, div, tds, marginDiv,
 			divReset = "padding:0;margin:0;border:0;display:block;overflow:hidden;",
 			body = document.getElementsByTagName("body")[0];
@@ -1509,7 +1500,7 @@
 var rbrace = /(?:\{[\s\S]*\}|\[[\s\S]*\])$/,
 	rmultiDash = /([A-Z])/g;
 
-jQuery.extend({
+jqAjax.extend({
 	cache: {},
 
 	deletedIds: [],
@@ -1517,9 +1508,9 @@
 	// Remove at next major release (1.9/2.0)
 	uuid: 0,
 
-	// Unique for each copy of jQuery on the page
-	// Non-digits removed to match rinlinejQuery
-	expando: "jQuery" + ( jQuery.fn.jquery + Math.random() ).replace( /\D/g, "" ),
+	// Unique for each copy of jqAjax on the page
+	// Non-digits removed to match rinlinejqAjax
+	expando: "jqAjax" + ( jqAjax.fn.jqajax + Math.random() ).replace( /\D/g, "" ),
 
 	// The following elements throw uncatchable exceptions if you
 	// attempt to add expando properties to them.
@@ -1531,26 +1522,26 @@
 	},
 
 	hasData: function( elem ) {
-		elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];
+		elem = elem.nodeType ? jqAjax.cache[ elem[jqAjax.expando] ] : elem[ jqAjax.expando ];
 		return !!elem && !isEmptyDataObject( elem );
 	},
 
 	data: function( elem, name, data, pvt /* Internal Use Only */ ) {
-		if ( !jQuery.acceptData( elem ) ) {
+		if ( !jqAjax.acceptData( elem ) ) {
 			return;
 		}
 
 		var thisCache, ret,
-			internalKey = jQuery.expando,
+			internalKey = jqAjax.expando,
 			getByName = typeof name === "string",
 
 			// We have to handle DOM nodes and JS objects differently because IE6-7
 			// can't GC object references properly across the DOM-JS boundary
 			isNode = elem.nodeType,
 
-			// Only DOM nodes need the global jQuery cache; JS object data is
+			// Only DOM nodes need the global jqAjax cache; JS object data is
 			// attached directly to the object so GC can occur automatically
-			cache = isNode ? jQuery.cache : elem,
+			cache = isNode ? jqAjax.cache : elem,
 
 			// Only defining an ID for JS objects if its cache already exists allows
 			// the code to shortcut on the same path as a DOM node with no cache
@@ -1566,7 +1557,7 @@
 			// Only DOM nodes need a new unique ID for each element since their data
 			// ends up in the global cache
 			if ( isNode ) {
-				elem[ internalKey ] = id = jQuery.deletedIds.pop() || jQuery.guid++;
+				elem[ internalKey ] = id = jqAjax.deletedIds.pop() || jqAjax.guid++;
 			} else {
 				id = internalKey;
 			}
@@ -1575,26 +1566,26 @@
 		if ( !cache[ id ] ) {
 			cache[ id ] = {};
 
-			// Avoids exposing jQuery metadata on plain JS objects when the object
+			// Avoids exposing jqAjax metadata on plain JS objects when the object
 			// is serialized using JSON.stringify
 			if ( !isNode ) {
-				cache[ id ].toJSON = jQuery.noop;
+				cache[ id ].toJSON = jqAjax.noop;
 			}
 		}
 
-		// An object can be passed to jQuery.data instead of a key/value pair; this gets
+		// An object can be passed to jqAjax.data instead of a key/value pair; this gets
 		// shallow copied over onto the existing cache
 		if ( typeof name === "object" || typeof name === "function" ) {
 			if ( pvt ) {
-				cache[ id ] = jQuery.extend( cache[ id ], name );
+				cache[ id ] = jqAjax.extend( cache[ id ], name );
 			} else {
-				cache[ id ].data = jQuery.extend( cache[ id ].data, name );
+				cache[ id ].data = jqAjax.extend( cache[ id ].data, name );
 			}
 		}
 
 		thisCache = cache[ id ];
 
-		// jQuery data() is stored in a separate object inside the object's internal data
+		// jqAjax data() is stored in a separate object inside the object's internal data
 		// cache in order to avoid key collisions between internal data and user-defined
 		// data.
 		if ( !pvt ) {
@@ -1606,7 +1597,7 @@
 		}
 
 		if ( data !== undefined ) {
-			thisCache[ jQuery.camelCase( name ) ] = data;
+			thisCache[ jqAjax.camelCase( name ) ] = data;
 		}
 
 		// Check for both converted-to-camel and non-converted data property names
@@ -1620,7 +1611,7 @@
 			if ( ret == null ) {
 
 				// Try to find the camelCased property
-				ret = thisCache[ jQuery.camelCase( name ) ];
+				ret = thisCache[ jqAjax.camelCase( name ) ];
 			}
 		} else {
 			ret = thisCache;
@@ -1630,7 +1621,7 @@
 	},
 
 	removeData: function( elem, name, pvt /* Internal Use Only */ ) {
-		if ( !jQuery.acceptData( elem ) ) {
+		if ( !jqAjax.acceptData( elem ) ) {
 			return;
 		}
 
@@ -1638,9 +1629,9 @@
 
 			isNode = elem.nodeType,
 
-			// See jQuery.data for more information
-			cache = isNode ? jQuery.cache : elem,
-			id = isNode ? elem[ jQuery.expando ] : jQuery.expando;
+			// See jqAjax.data for more information
+			cache = isNode ? jqAjax.cache : elem,
+			id = isNode ? elem[ jqAjax.expando ] : jqAjax.expando;
 
 		// If there is already no cache entry for this object, there is no
 		// purpose in continuing
@@ -1655,7 +1646,7 @@
 			if ( thisCache ) {
 
 				// Support array or space separated string names for data keys
-				if ( !jQuery.isArray( name ) ) {
+				if ( !jqAjax.isArray( name ) ) {
 
 					// try the string as a key before any manipulation
 					if ( name in thisCache ) {
@@ -1663,7 +1654,7 @@
 					} else {
 
 						// split the camel cased version by spaces unless a key with the spaces exists
-						name = jQuery.camelCase( name );
+						name = jqAjax.camelCase( name );
 						if ( name in thisCache ) {
 							name = [ name ];
 						} else {
@@ -1678,13 +1669,13 @@
 
 				// If there is no data left in the cache, we want to continue
 				// and let the cache object itself get destroyed
-				if ( !( pvt ? isEmptyDataObject : jQuery.isEmptyObject )( thisCache ) ) {
+				if ( !( pvt ? isEmptyDataObject : jqAjax.isEmptyObject )( thisCache ) ) {
 					return;
 				}
 			}
 		}
 
-		// See jQuery.data for more information
+		// See jqAjax.data for more information
 		if ( !pvt ) {
 			delete cache[ id ].data;
 
@@ -1697,10 +1688,10 @@
 
 		// Destroy the cache
 		if ( isNode ) {
-			jQuery.cleanData( [ elem ], true );
+			jqAjax.cleanData( [ elem ], true );
 
 		// Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)
-		} else if ( jQuery.support.deleteExpando || cache != cache.window ) {
+		} else if ( jqAjax.support.deleteExpando || cache != cache.window ) {
 			delete cache[ id ];
 
 		// When all else fails, null
@@ -1711,19 +1702,19 @@
 
 	// For internal use only.
 	_data: function( elem, name, data ) {
-		return jQuery.data( elem, name, data, true );
+		return jqAjax.data( elem, name, data, true );
 	},
 
 	// A method for determining if a DOM node can handle the data expando
 	acceptData: function( elem ) {
-		var noData = elem.nodeName && jQuery.noData[ elem.nodeName.toLowerCase() ];
+		var noData = elem.nodeName && jqAjax.noData[ elem.nodeName.toLowerCase() ];
 
 		// nodes accept data unless otherwise specified; rejection can be conditional
 		return !noData || noData !== true && elem.getAttribute("classid") === noData;
 	}
 });
 
-jQuery.fn.extend({
+jqAjax.fn.extend({
 	data: function( key, value ) {
 		var parts, part, attr, name, l,
 			elem = this[0],
@@ -1733,20 +1724,20 @@
 		// Gets all values
 		if ( key === undefined ) {
 			if ( this.length ) {
-				data = jQuery.data( elem );
+				data = jqAjax.data( elem );
 
-				if ( elem.nodeType === 1 && !jQuery._data( elem, "parsedAttrs" ) ) {
+				if ( elem.nodeType === 1 && !jqAjax._data( elem, "parsedAttrs" ) ) {
 					attr = elem.attributes;
 					for ( l = attr.length; i < l; i++ ) {
 						name = attr[i].name;
 
 						if ( !name.indexOf( "data-" ) ) {
-							name = jQuery.camelCase( name.substring(5) );
+							name = jqAjax.camelCase( name.substring(5) );
 
 							dataAttr( elem, name, data[ name ] );
 						}
 					}
-					jQuery._data( elem, "parsedAttrs", true );
+					jqAjax._data( elem, "parsedAttrs", true );
 				}
 			}
 
@@ -1756,7 +1747,7 @@
 		// Sets multiple values
 		if ( typeof key === "object" ) {
 			return this.each(function() {
-				jQuery.data( this, key );
+				jqAjax.data( this, key );
 			});
 		}
 
@@ -1764,14 +1755,14 @@
 		parts[1] = parts[1] ? "." + parts[1] : "";
 		part = parts[1] + "!";
 
-		return jQuery.access( this, function( value ) {
+		return jqAjax.access( this, function( value ) {
 
 			if ( value === undefined ) {
 				data = this.triggerHandler( "getData" + part, [ parts[0] ] );
 
 				// Try to fetch any internally stored data first
 				if ( data === undefined && elem ) {
-					data = jQuery.data( elem, key );
+					data = jqAjax.data( elem, key );
 					data = dataAttr( elem, key, data );
 				}
 
@@ -1782,10 +1773,10 @@
 
 			parts[1] = value;
 			this.each(function() {
-				var self = jQuery( this );
+				var self = jqAjax( this );
 
 				self.triggerHandler( "setData" + part, parts );
-				jQuery.data( this, key, value );
+				jqAjax.data( this, key, value );
 				self.triggerHandler( "changeData" + part, parts );
 			});
 		}, null, value, arguments.length > 1, null, false );
@@ -1793,7 +1784,7 @@
 
 	removeData: function( key ) {
 		return this.each(function() {
-			jQuery.removeData( this, key );
+			jqAjax.removeData( this, key );
 		});
 	}
 });
@@ -1814,12 +1805,12 @@
 				data === "null" ? null :
 				// Only convert to a number if it doesn't change the string
 				+data + "" === data ? +data :
-				rbrace.test( data ) ? jQuery.parseJSON( data ) :
+				rbrace.test( data ) ? jqAjax.parseJSON( data ) :
 					data;
 			} catch( e ) {}
 
 			// Make sure we set the data so it isn't changed later
-			jQuery.data( elem, key, data );
+			jqAjax.data( elem, key, data );
 
 		} else {
 			data = undefined;
@@ -1835,7 +1826,7 @@
 	for ( name in obj ) {
 
 		// if the public data object is empty, the private is still empty
-		if ( name === "data" && jQuery.isEmptyObject( obj[name] ) ) {
+		if ( name === "data" && jqAjax.isEmptyObject( obj[name] ) ) {
 			continue;
 		}
 		if ( name !== "toJSON" ) {
@@ -1852,14 +1843,14 @@
 	rmouseEvent = /^(?:mouse|contextmenu)|click/,
 	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
 	hoverHack = function( events ) {
-		return jQuery.event.special.hover ? events : events.replace( rhoverHack, "mouseenter$1 mouseleave$1" );
+		return jqAjax.event.special.hover ? events : events.replace( rhoverHack, "mouseenter$1 mouseleave$1" );
 	};
 
 /*
  * Helper functions for managing events -- not part of the public interface.
  * Props to Dean Edwards' addEvent library for many of the ideas.
  */
-jQuery.event = {
+jqAjax.event = {
 
 	add: function( elem, types, handler, data, selector ) {
 
@@ -1868,7 +1859,7 @@
 			handleObjIn, handlers, special;
 
 		// Don't attach events to noData or text/comment nodes (allow plain objects tho)
-		if ( elem.nodeType === 3 || elem.nodeType === 8 || !types || !handler || !(elemData = jQuery._data( elem )) ) {
+		if ( elem.nodeType === 3 || elem.nodeType === 8 || !types || !handler || !(elemData = jqAjax._data( elem )) ) {
 			return;
 		}
 
@@ -1881,7 +1872,7 @@
 
 		// Make sure that the handler has a unique ID, used to find/remove it later
 		if ( !handler.guid ) {
-			handler.guid = jQuery.guid++;
+			handler.guid = jqAjax.guid++;
 		}
 
 		// Init the element's event structure and main handler, if this is the first
@@ -1892,10 +1883,10 @@
 		eventHandle = elemData.handle;
 		if ( !eventHandle ) {
 			elemData.handle = eventHandle = function( e ) {
-				// Discard the second event of a jQuery.event.trigger() and
+				// Discard the second event of a jqAjax.event.trigger() and
 				// when an event is called after a page has unloaded
-				return typeof jQuery !== "undefined" && (!e || jQuery.event.triggered !== e.type) ?
-					jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
+				return typeof jqAjax !== "undefined" && (!e || jqAjax.event.triggered !== e.type) ?
+					jqAjax.event.dispatch.apply( eventHandle.elem, arguments ) :
 					undefined;
 			};
 			// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
@@ -1903,8 +1894,8 @@
 		}
 
 		// Handle multiple events separated by a space
-		// jQuery(...).bind("mouseover mouseout", fn);
-		types = jQuery.trim( hoverHack(types) ).split( " " );
+		// jqAjax(...).bind("mouseover mouseout", fn);
+		types = jqAjax.trim( hoverHack(types) ).split( " " );
 		for ( t = 0; t < types.length; t++ ) {
 
 			tns = rtypenamespace.exec( types[t] ) || [];
@@ -1912,23 +1903,23 @@
 			namespaces = ( tns[2] || "" ).split( "." ).sort();
 
 			// If event changes its type, use the special event handlers for the changed type
-			special = jQuery.event.special[ type ] || {};
+			special = jqAjax.event.special[ type ] || {};
 
 			// If selector defined, determine special event api type, otherwise given type
 			type = ( selector ? special.delegateType : special.bindType ) || type;
 
 			// Update special based on newly reset type
-			special = jQuery.event.special[ type ] || {};
+			special = jqAjax.event.special[ type ] || {};
 
 			// handleObj is passed to all event handlers
-			handleObj = jQuery.extend({
+			handleObj = jqAjax.extend({
 				type: type,
 				origType: tns[1],
 				data: data,
 				handler: handler,
 				guid: handler.guid,
 				selector: selector,
-				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
+				needsContext: selector && jqAjax.expr.match.needsContext.test( selector ),
 				namespace: namespaces.join(".")
 			}, handleObjIn );
 
@@ -1966,7 +1957,7 @@
 			}
 
 			// Keep track of which events have ever been used, for event optimization
-			jQuery.event.global[ type ] = true;
+			jqAjax.event.global[ type ] = true;
 		}
 
 		// Nullify elem to prevent memory leaks in IE
@@ -1980,14 +1971,14 @@
 
 		var t, tns, type, origType, namespaces, origCount,
 			j, events, special, eventType, handleObj,
-			elemData = jQuery.hasData( elem ) && jQuery._data( elem );
+			elemData = jqAjax.hasData( elem ) && jqAjax._data( elem );
 
 		if ( !elemData || !(events = elemData.events) ) {
 			return;
 		}
 
 		// Once for each type.namespace in types; type may be omitted
-		types = jQuery.trim( hoverHack( types || "" ) ).split(" ");
+		types = jqAjax.trim( hoverHack( types || "" ) ).split(" ");
 		for ( t = 0; t < types.length; t++ ) {
 			tns = rtypenamespace.exec( types[t] ) || [];
 			type = origType = tns[1];
@@ -1996,12 +1987,12 @@
 			// Unbind all events (on this namespace, if provided) for the element
 			if ( !type ) {
 				for ( type in events ) {
-					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
+					jqAjax.event.remove( elem, type + types[ t ], handler, selector, true );
 				}
 				continue;
 			}
 
-			special = jQuery.event.special[ type ] || {};
+			special = jqAjax.event.special[ type ] || {};
 			type = ( selector? special.delegateType : special.bindType ) || type;
 			eventType = events[ type ] || [];
 			origCount = eventType.length;
@@ -2030,7 +2021,7 @@
 			// (avoids potential for endless recursion during removal of special event handlers)
 			if ( eventType.length === 0 && origCount !== eventType.length ) {
 				if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
-					jQuery.removeEvent( elem, type, elemData.handle );
+					jqAjax.removeEvent( elem, type, elemData.handle );
 				}
 
 				delete events[ type ];
@@ -2038,12 +2029,12 @@
 		}
 
 		// Remove the expando if it's no longer used
-		if ( jQuery.isEmptyObject( events ) ) {
+		if ( jqAjax.isEmptyObject( events ) ) {
 			delete elemData.handle;
 
 			// removeData also checks for emptiness and clears the expando if empty
 			// so use it instead of delete
-			jQuery.removeData( elem, "events", true );
+			jqAjax.removeData( elem, "events", true );
 		}
 	},
 
@@ -2067,7 +2058,7 @@
 			namespaces = [];
 
 		// focus/blur morphs to focusin/out; ensure we're not firing them right now
-		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
+		if ( rfocusMorph.test( type + jqAjax.event.triggered ) ) {
 			return;
 		}
 
@@ -2084,19 +2075,19 @@
 			namespaces.sort();
 		}
 
-		if ( (!elem || jQuery.event.customEvent[ type ]) && !jQuery.event.global[ type ] ) {
-			// No jQuery handlers for this event type, and it can't have inline handlers
+		if ( (!elem || jqAjax.event.customEvent[ type ]) && !jqAjax.event.global[ type ] ) {
+			// No jqAjax handlers for this event type, and it can't have inline handlers
 			return;
 		}
 
 		// Caller can pass in an Event, Object, or just an event type string
 		event = typeof event === "object" ?
-			// jQuery.Event object
-			event[ jQuery.expando ] ? event :
+			// jqAjax.Event object
+			event[ jqAjax.expando ] ? event :
 			// Object literal
-			new jQuery.Event( type, event ) :
+			new jqAjax.Event( type, event ) :
 			// Just the event type (string)
-			new jQuery.Event( type );
+			new jqAjax.Event( type );
 
 		event.type = type;
 		event.isTrigger = true;
@@ -2109,10 +2100,10 @@
 		if ( !elem ) {
 
 			// TODO: Stop taunting the data cache; remove global events and always attach to document
-			cache = jQuery.cache;
+			cache = jqAjax.cache;
 			for ( i in cache ) {
 				if ( cache[ i ].events && cache[ i ].events[ type ] ) {
-					jQuery.event.trigger( event, data, cache[ i ].handle.elem, true );
+					jqAjax.event.trigger( event, data, cache[ i ].handle.elem, true );
 				}
 			}
 			return;
@@ -2125,11 +2116,11 @@
 		}
 
 		// Clone any incoming data and prepend the event, creating the handler arg list
-		data = data != null ? jQuery.makeArray( data ) : [];
+		data = data != null ? jqAjax.makeArray( data ) : [];
 		data.unshift( event );
 
 		// Allow special events to draw outside the lines
-		special = jQuery.event.special[ type ] || {};
+		special = jqAjax.event.special[ type ] || {};
 		if ( special.trigger && special.trigger.apply( elem, data ) === false ) {
 			return;
 		}
@@ -2137,7 +2128,7 @@
 		// Determine event propagation path in advance, per W3C events spec (#9951)
 		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
 		eventPath = [[ elem, special.bindType || type ]];
-		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {
+		if ( !onlyHandlers && !special.noBubble && !jqAjax.isWindow( elem ) ) {
 
 			bubbleType = special.delegateType || type;
 			cur = rfocusMorph.test( bubbleType + type ) ? elem : elem.parentNode;
@@ -2158,13 +2149,13 @@
 			cur = eventPath[i][0];
 			event.type = eventPath[i][1];
 
-			handle = ( jQuery._data( cur, "events" ) || {} )[ event.type ] && jQuery._data( cur, "handle" );
+			handle = ( jqAjax._data( cur, "events" ) || {} )[ event.type ] && jqAjax._data( cur, "handle" );
 			if ( handle ) {
 				handle.apply( cur, data );
 			}
-			// Note that this is a bare JS function and not a jQuery handler
+			// Note that this is a bare JS function and not a jqAjax handler
 			handle = ontype && cur[ ontype ];
-			if ( handle && jQuery.acceptData( cur ) && handle.apply && handle.apply( cur, data ) === false ) {
+			if ( handle && jqAjax.acceptData( cur ) && handle.apply && handle.apply( cur, data ) === false ) {
 				event.preventDefault();
 			}
 		}
@@ -2174,13 +2165,13 @@
 		if ( !onlyHandlers && !event.isDefaultPrevented() ) {
 
 			if ( (!special._default || special._default.apply( elem.ownerDocument, data ) === false) &&
-				!(type === "click" && jQuery.nodeName( elem, "a" )) && jQuery.acceptData( elem ) ) {
+				!(type === "click" && jqAjax.nodeName( elem, "a" )) && jqAjax.acceptData( elem ) ) {
 
 				// Call a native DOM method on the target with the same name name as the event.
 				// Can't use an .isFunction() check here because IE6/7 fails that test.
 				// Don't do default actions on window, that's where global variables be (#6170)
 				// IE<9 dies on focus/blur to hidden element (#1486)
-				if ( ontype && elem[ type ] && ((type !== "focus" && type !== "blur") || event.target.offsetWidth !== 0) && !jQuery.isWindow( elem ) ) {
+				if ( ontype && elem[ type ] && ((type !== "focus" && type !== "blur") || event.target.offsetWidth !== 0) && !jqAjax.isWindow( elem ) ) {
 
 					// Don't re-trigger an onFOO event when we call its FOO() method
 					old = elem[ ontype ];
@@ -2190,9 +2181,9 @@
 					}
 
 					// Prevent re-triggering of the same event, since we already bubbled it above
-					jQuery.event.triggered = type;
+					jqAjax.event.triggered = type;
 					elem[ type ]();
-					jQuery.event.triggered = undefined;
+					jqAjax.event.triggered = undefined;
 
 					if ( old ) {
 						elem[ ontype ] = old;
@@ -2206,18 +2197,18 @@
 
 	dispatch: function( event ) {
 
-		// Make a writable jQuery.Event from the native event object
-		event = jQuery.event.fix( event || window.event );
+		// Make a writable jqAjax.Event from the native event object
+		event = jqAjax.event.fix( event || window.event );
 
 		var i, j, cur, ret, selMatch, matched, matches, handleObj, sel, related,
-			handlers = ( (jQuery._data( this, "events" ) || {} )[ event.type ] || []),
+			handlers = ( (jqAjax._data( this, "events" ) || {} )[ event.type ] || []),
 			delegateCount = handlers.delegateCount,
 			args = core_slice.call( arguments ),
 			run_all = !event.exclusive && !event.namespace,
-			special = jQuery.event.special[ event.type ] || {},
+			special = jqAjax.event.special[ event.type ] || {},
 			handlerQueue = [];
 
-		// Use the fix-ed jQuery.Event rather than the (read-only) native event
+		// Use the fix-ed jqAjax.Event rather than the (read-only) native event
 		args[0] = event;
 		event.delegateTarget = this;
 
@@ -2242,8 +2233,8 @@
 
 						if ( selMatch[ sel ] === undefined ) {
 							selMatch[ sel ] = handleObj.needsContext ?
-								jQuery( sel, this ).index( cur ) >= 0 :
-								jQuery.find( sel, this, null, [ cur ] ).length;
+								jqAjax( sel, this ).index( cur ) >= 0 :
+								jqAjax.find( sel, this, null, [ cur ] ).length;
 						}
 						if ( selMatch[ sel ] ) {
 							matches.push( handleObj );
@@ -2276,7 +2267,7 @@
 					event.data = handleObj.data;
 					event.handleObj = handleObj;
 
-					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
+					ret = ( (jqAjax.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
 							.apply( matched.elem, args );
 
 					if ( ret !== undefined ) {
@@ -2350,17 +2341,17 @@
 	},
 
 	fix: function( event ) {
-		if ( event[ jQuery.expando ] ) {
+		if ( event[ jqAjax.expando ] ) {
 			return event;
 		}
 
 		// Create a writable copy of the event object and normalize some properties
 		var i, prop,
 			originalEvent = event,
-			fixHook = jQuery.event.fixHooks[ event.type ] || {},
+			fixHook = jqAjax.event.fixHooks[ event.type ] || {},
 			copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;
 
-		event = jQuery.Event( originalEvent );
+		event = jqAjax.Event( originalEvent );
 
 		for ( i = copy.length; i; ) {
 			prop = copy[ --i ];
@@ -2399,7 +2390,7 @@
 		beforeunload: {
 			setup: function( data, namespaces, eventHandle ) {
 				// We only want to do this special case on windows
-				if ( jQuery.isWindow( this ) ) {
+				if ( jqAjax.isWindow( this ) ) {
 					this.onbeforeunload = eventHandle;
 				}
 			},
@@ -2416,8 +2407,8 @@
 		// Piggyback on a donor event to simulate a different one.
 		// Fake originalEvent to avoid donor's stopPropagation, but if the
 		// simulated event prevents default then we do the same on the donor.
-		var e = jQuery.extend(
-			new jQuery.Event(),
+		var e = jqAjax.extend(
+			new jqAjax.Event(),
 			event,
 			{ type: type,
 				isSimulated: true,
@@ -2425,9 +2416,9 @@
 			}
 		);
 		if ( bubble ) {
-			jQuery.event.trigger( e, null, elem );
+			jqAjax.event.trigger( e, null, elem );
 		} else {
-			jQuery.event.dispatch.call( elem, e );
+			jqAjax.event.dispatch.call( elem, e );
 		}
 		if ( e.isDefaultPrevented() ) {
 			event.preventDefault();
@@ -2437,9 +2428,9 @@
 
 // Some plugins are using, but it's undocumented/deprecated and will be removed.
 // The 1.7 special event interface should provide all the hooks needed now.
-jQuery.event.handle = jQuery.event.dispatch;
+jqAjax.event.handle = jqAjax.event.dispatch;
 
-jQuery.removeEvent = document.removeEventListener ?
+jqAjax.removeEvent = document.removeEventListener ?
 	function( elem, type, handle ) {
 		if ( elem.removeEventListener ) {
 			elem.removeEventListener( type, handle, false );
@@ -2460,10 +2451,10 @@
 		}
 	};
 
-jQuery.Event = function( src, props ) {
+jqAjax.Event = function( src, props ) {
 	// Allow instantiation without the 'new' keyword
-	if ( !(this instanceof jQuery.Event) ) {
-		return new jQuery.Event( src, props );
+	if ( !(this instanceof jqAjax.Event) ) {
+		return new jqAjax.Event( src, props );
 	}
 
 	// Event object
@@ -2483,14 +2474,14 @@
 
 	// Put explicitly provided properties onto the event object
 	if ( props ) {
-		jQuery.extend( this, props );
+		jqAjax.extend( this, props );
 	}
 
 	// Create a timestamp if incoming event doesn't have one
-	this.timeStamp = src && src.timeStamp || jQuery.now();
+	this.timeStamp = src && src.timeStamp || jqAjax.now();
 
 	// Mark it as fixed
-	this[ jQuery.expando ] = true;
+	this[ jqAjax.expando ] = true;
 };
 
 function returnFalse() {
@@ -2500,9 +2491,9 @@
 	return true;
 }
 
-// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
+// jqAjax.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
 // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
-jQuery.Event.prototype = {
+jqAjax.Event.prototype = {
 	preventDefault: function() {
 		this.isDefaultPrevented = returnTrue;
 
@@ -2544,11 +2535,11 @@
 };
 
 // Create mouseenter/leave events using mouseover/out and event-time checks
-jQuery.each({
+jqAjax.each({
 	mouseenter: "mouseover",
 	mouseleave: "mouseout"
 }, function( orig, fix ) {
-	jQuery.event.special[ orig ] = {
+	jqAjax.event.special[ orig ] = {
 		delegateType: fix,
 		bindType: fix,
 
@@ -2561,7 +2552,7 @@
 
 			// For mousenter/leave call the handler if related is outside the target.
 			// NB: No relatedTarget if the mouse left/entered the browser window
-			if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
+			if ( !related || (related !== target && !jqAjax.contains( target, related )) ) {
 				event.type = handleObj.origType;
 				ret = handleObj.handler.apply( this, arguments );
 				event.type = fix;
@@ -2572,25 +2563,25 @@
 });
 
 // IE submit delegation
-if ( !jQuery.support.submitBubbles ) {
+if ( !jqAjax.support.submitBubbles ) {
 
-	jQuery.event.special.submit = {
+	jqAjax.event.special.submit = {
 		setup: function() {
 			// Only need this for delegated form submit events
-			if ( jQuery.nodeName( this, "form" ) ) {
+			if ( jqAjax.nodeName( this, "form" ) ) {
 				return false;
 			}
 
 			// Lazy-add a submit handler when a descendant form may potentially be submitted
-			jQuery.event.add( this, "click._submit keypress._submit", function( e ) {
+			jqAjax.event.add( this, "click._submit keypress._submit", function( e ) {
 				// Node name check avoids a VML-related crash in IE (#9807)
 				var elem = e.target,
-					form = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ? elem.form : undefined;
-				if ( form && !jQuery._data( form, "_submit_attached" ) ) {
-					jQuery.event.add( form, "submit._submit", function( event ) {
+					form = jqAjax.nodeName( elem, "input" ) || jqAjax.nodeName( elem, "button" ) ? elem.form : undefined;
+				if ( form && !jqAjax._data( form, "_submit_attached" ) ) {
+					jqAjax.event.add( form, "submit._submit", function( event ) {
 						event._submit_bubble = true;
 					});
-					jQuery._data( form, "_submit_attached", true );
+					jqAjax._data( form, "_submit_attached", true );
 				}
 			});
 			// return undefined since we don't need an event listener
@@ -2601,27 +2592,27 @@
 			if ( event._submit_bubble ) {
 				delete event._submit_bubble;
 				if ( this.parentNode && !event.isTrigger ) {
-					jQuery.event.simulate( "submit", this.parentNode, event, true );
+					jqAjax.event.simulate( "submit", this.parentNode, event, true );
 				}
 			}
 		},
 
 		teardown: function() {
 			// Only need this for delegated form submit events
-			if ( jQuery.nodeName( this, "form" ) ) {
+			if ( jqAjax.nodeName( this, "form" ) ) {
 				return false;
 			}
 
 			// Remove delegated handlers; cleanData eventually reaps submit handlers attached above
-			jQuery.event.remove( this, "._submit" );
+			jqAjax.event.remove( this, "._submit" );
 		}
 	};
 }
 
 // IE change delegation and checkbox/radio fix
-if ( !jQuery.support.changeBubbles ) {
+if ( !jqAjax.support.changeBubbles ) {
 
-	jQuery.event.special.change = {
+	jqAjax.event.special.change = {
 
 		setup: function() {
 
@@ -2630,32 +2621,32 @@
 				// after a propertychange. Eat the blur-change in special.change.handle.
 				// This still fires onchange a second time for check/radio after blur.
 				if ( this.type === "checkbox" || this.type === "radio" ) {
-					jQuery.event.add( this, "propertychange._change", function( event ) {
+					jqAjax.event.add( this, "propertychange._change", function( event ) {
 						if ( event.originalEvent.propertyName === "checked" ) {
 							this._just_changed = true;
 						}
 					});
-					jQuery.event.add( this, "click._change", function( event ) {
+					jqAjax.event.add( this, "click._change", function( event ) {
 						if ( this._just_changed && !event.isTrigger ) {
 							this._just_changed = false;
 						}
 						// Allow triggered, simulated change events (#11500)
-						jQuery.event.simulate( "change", this, event, true );
+						jqAjax.event.simulate( "change", this, event, true );
 					});
 				}
 				return false;
 			}
 			// Delegated event; lazy-add a change handler on descendant inputs
-			jQuery.event.add( this, "beforeactivate._change", function( e ) {
+			jqAjax.event.add( this, "beforeactivate._change", function( e ) {
 				var elem = e.target;
 
-				if ( rformElems.test( elem.nodeName ) && !jQuery._data( elem, "_change_attached" ) ) {
-					jQuery.event.add( elem, "change._change", function( event ) {
+				if ( rformElems.test( elem.nodeName ) && !jqAjax._data( elem, "_change_attached" ) ) {
+					jqAjax.event.add( elem, "change._change", function( event ) {
 						if ( this.parentNode && !event.isSimulated && !event.isTrigger ) {
-							jQuery.event.simulate( "change", this.parentNode, event, true );
+							jqAjax.event.simulate( "change", this.parentNode, event, true );
 						}
 					});
-					jQuery._data( elem, "_change_attached", true );
+					jqAjax._data( elem, "_change_attached", true );
 				}
 			});
 		},
@@ -2670,7 +2661,7 @@
 		},
 
 		teardown: function() {
-			jQuery.event.remove( this, "._change" );
+			jqAjax.event.remove( this, "._change" );
 
 			return !rformElems.test( this.nodeName );
 		}
@@ -2678,16 +2669,16 @@
 }
 
 // Create "bubbling" focus and blur events
-if ( !jQuery.support.focusinBubbles ) {
-	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {
+if ( !jqAjax.support.focusinBubbles ) {
+	jqAjax.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {
 
 		// Attach a single capturing handler while someone wants focusin/focusout
 		var attaches = 0,
 			handler = function( event ) {
-				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
+				jqAjax.event.simulate( fix, event.target, jqAjax.event.fix( event ), true );
 			};
 
-		jQuery.event.special[ fix ] = {
+		jqAjax.event.special[ fix ] = {
 			setup: function() {
 				if ( attaches++ === 0 ) {
 					document.addEventListener( orig, handler, true );
@@ -2702,7 +2693,7 @@
 	});
 }
 
-jQuery.fn.extend({
+jqAjax.fn.extend({
 
 	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
 		var origFn, type;
@@ -2747,14 +2738,14 @@
 			origFn = fn;
 			fn = function( event ) {
 				// Can use an empty set, since event contains the info
-				jQuery().off( event );
+				jqAjax().off( event );
 				return origFn.apply( this, arguments );
 			};
 			// Use same guid so caller can remove using origFn
-			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
+			fn.guid = origFn.guid || ( origFn.guid = jqAjax.guid++ );
 		}
 		return this.each( function() {
-			jQuery.event.add( this, types, fn, data, selector );
+			jqAjax.event.add( this, types, fn, data, selector );
 		});
 	},
 	one: function( types, selector, data, fn ) {
@@ -2763,9 +2754,9 @@
 	off: function( types, selector, fn ) {
 		var handleObj, type;
 		if ( types && types.preventDefault && types.handleObj ) {
-			// ( event )  dispatched jQuery.Event
+			// ( event )  dispatched jqAjax.Event
 			handleObj = types.handleObj;
-			jQuery( types.delegateTarget ).off(
+			jqAjax( types.delegateTarget ).off(
 				handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
 				handleObj.selector,
 				handleObj.handler
@@ -2788,7 +2779,7 @@
 			fn = returnFalse;
 		}
 		return this.each(function() {
-			jQuery.event.remove( this, types, fn, selector );
+			jqAjax.event.remove( this, types, fn, selector );
 		});
 	},
 
@@ -2800,11 +2791,11 @@
 	},
 
 	live: function( types, data, fn ) {
-		jQuery( this.context ).on( types, this.selector, data, fn );
+		jqAjax( this.context ).on( types, this.selector, data, fn );
 		return this;
 	},
 	die: function( types, fn ) {
-		jQuery( this.context ).off( types, this.selector || "**", fn );
+		jqAjax( this.context ).off( types, this.selector || "**", fn );
 		return this;
 	},
 
@@ -2818,24 +2809,24 @@
 
 	trigger: function( type, data ) {
 		return this.each(function() {
-			jQuery.event.trigger( type, data, this );
+			jqAjax.event.trigger( type, data, this );
 		});
 	},
 	triggerHandler: function( type, data ) {
 		if ( this[0] ) {
-			return jQuery.event.trigger( type, data, this[0], true );
+			return jqAjax.event.trigger( type, data, this[0], true );
 		}
 	},
 
 	toggle: function( fn ) {
 		// Save reference to arguments for access in closure
 		var args = arguments,
-			guid = fn.guid || jQuery.guid++,
+			guid = fn.guid || jqAjax.guid++,
 			i = 0,
 			toggler = function( event ) {
 				// Figure out which function to execute
-				var lastToggle = ( jQuery._data( this, "lastToggle" + fn.guid ) || 0 ) % i;
-				jQuery._data( this, "lastToggle" + fn.guid, lastToggle + 1 );
+				var lastToggle = ( jqAjax._data( this, "lastToggle" + fn.guid ) || 0 ) % i;
+				jqAjax._data( this, "lastToggle" + fn.guid, lastToggle + 1 );
 
 				// Make sure that clicks stop
 				event.preventDefault();
@@ -2858,12 +2849,12 @@
 	}
 });
 
-jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
+jqAjax.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
 	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
 	"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {
 
 	// Handle event binding
-	jQuery.fn[ name ] = function( data, fn ) {
+	jqAjax.fn[ name ] = function( data, fn ) {
 		if ( fn == null ) {
 			fn = data;
 			data = null;
@@ -2875,11 +2866,11 @@
 	};
 
 	if ( rkeyEvent.test( name ) ) {
-		jQuery.event.fixHooks[ name ] = jQuery.event.keyHooks;
+		jqAjax.event.fixHooks[ name ] = jqAjax.event.keyHooks;
 	}
 
 	if ( rmouseEvent.test( name ) ) {
-		jQuery.event.fixHooks[ name ] = jQuery.event.mouseHooks;
+		jqAjax.event.fixHooks[ name ] = jqAjax.event.mouseHooks;
 	}
 });
 var r20 = /%20/g,
@@ -2888,13 +2879,13 @@
 	rinput = /^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,
 	rselectTextarea = /^(?:select|textarea)/i;
 
-jQuery.fn.extend({
+jqAjax.fn.extend({
 	serialize: function() {
-		return jQuery.param( this.serializeArray() );
+		return jqAjax.param( this.serializeArray() );
 	},
 	serializeArray: function() {
 		return this.map(function(){
-			return this.elements ? jQuery.makeArray( this.elements ) : this;
+			return this.elements ? jqAjax.makeArray( this.elements ) : this;
 		})
 		.filter(function(){
 			return this.name && !this.disabled &&
@@ -2902,12 +2893,12 @@
 					rinput.test( this.type ) );
 		})
 		.map(function( i, elem ){
-			var val = jQuery( this ).val();
+			var val = jqAjax( this ).val();
 
 			return val == null ?
 				null :
-				jQuery.isArray( val ) ?
-					jQuery.map( val, function( val, i ){
+				jqAjax.isArray( val ) ?
+					jqAjax.map( val, function( val, i ){
 						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
 					}) :
 					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
@@ -2917,24 +2908,24 @@
 
 //Serialize an array of form elements or a set of
 //key/values into a query string
-jQuery.param = function( a, traditional ) {
+jqAjax.param = function( a, traditional ) {
 	var prefix,
 		s = [],
 		add = function( key, value ) {
 			// If value is a function, invoke it and return its value
-			value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
+			value = jqAjax.isFunction( value ) ? value() : ( value == null ? "" : value );
 			s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
 		};
 
-	// Set traditional to true for jQuery <= 1.3.2 behavior.
+	// Set traditional to true for jqAjax <= 1.3.2 behavior.
 	if ( traditional === undefined ) {
-		traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
+		traditional = jqAjax.ajaxSettings && jqAjax.ajaxSettings.traditional;
 	}
 
 	// If an array was passed in, assume that it is an array of form elements.
-	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
+	if ( jqAjax.isArray( a ) || ( a.jqajax && !jqAjax.isPlainObject( a ) ) ) {
 		// Serialize the form elements
-		jQuery.each( a, function() {
+		jqAjax.each( a, function() {
 			add( this.name, this.value );
 		});
 
@@ -2953,9 +2944,9 @@
 function buildParams( prefix, obj, traditional, add ) {
 	var name;
 
-	if ( jQuery.isArray( obj ) ) {
+	if ( jqAjax.isArray( obj ) ) {
 		// Serialize array item.
-		jQuery.each( obj, function( i, v ) {
+		jqAjax.each( obj, function( i, v ) {
 			if ( traditional || rbracket.test( prefix ) ) {
 				// Treat each array item as a scalar.
 				add( prefix, v );
@@ -2972,7 +2963,7 @@
 			}
 		});
 
-	} else if ( !traditional && jQuery.type( obj ) === "object" ) {
+	} else if ( !traditional && jqAjax.type( obj ) === "object" ) {
 		// Serialize object item.
 		for ( name in obj ) {
 			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
@@ -3000,7 +2991,7 @@
 	rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,
 
 	// Keep a copy of the old load method
-	_load = jQuery.fn.load,
+	_load = jqAjax.fn.load,
 
 	/* Prefilters
 	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
@@ -3038,7 +3029,7 @@
 // Segment location into parts
 ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];
 
-// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
+// Base "constructor" for jqAjax.ajaxPrefilter and jqAjax.ajaxTransport
 function addToPrefiltersOrTransports( structure ) {
 
 	// dataTypeExpression is optional and defaults to "*"
@@ -3054,7 +3045,7 @@
 			i = 0,
 			length = dataTypes.length;
 
-		if ( jQuery.isFunction( func ) ) {
+		if ( jqAjax.isFunction( func ) ) {
 			// For each dataType in the dataTypeExpression
 			for ( ; i < length; i++ ) {
 				dataType = dataTypes[ i ];
@@ -3117,18 +3108,18 @@
 // Fixes #9887
 function ajaxExtend( target, src ) {
 	var key, deep,
-		flatOptions = jQuery.ajaxSettings.flatOptions || {};
+		flatOptions = jqAjax.ajaxSettings.flatOptions || {};
 	for ( key in src ) {
 		if ( src[ key ] !== undefined ) {
 			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
 		}
 	}
 	if ( deep ) {
-		jQuery.extend( true, target, deep );
+		jqAjax.extend( true, target, deep );
 	}
 }
 
-jQuery.fn.load = function( url, params, callback ) {
+jqAjax.fn.load = function( url, params, callback ) {
 	if ( typeof url !== "string" && _load ) {
 		return _load.apply( this, arguments );
 	}
@@ -3148,7 +3139,7 @@
 	}
 
 	// If it's a function
-	if ( jQuery.isFunction( params ) ) {
+	if ( jqAjax.isFunction( params ) ) {
 
 		// We assume that it's the callback
 		callback = params;
@@ -3160,7 +3151,7 @@
 	}
 
 	// Request the remote document
-	jQuery.ajax({
+	jqAjax.ajax({
 		url: url,
 
 		// if "type" variable is undefined, then "GET" method will be used
@@ -3181,7 +3172,7 @@
 		self.html( selector ?
 
 			// Create a dummy div to hold the results
-			jQuery("<div>")
+			jqAjax("<div>")
 
 				// inject the contents of the document in, removing the scripts
 				// to avoid any 'Permission Denied' errors in IE
@@ -3199,22 +3190,22 @@
 };
 
 // Attach a bunch of functions for handling common AJAX events
-jQuery.each( "ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split( " " ), function( i, o ){
-	jQuery.fn[ o ] = function( f ){
+jqAjax.each( "ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split( " " ), function( i, o ){
+	jqAjax.fn[ o ] = function( f ){
 		return this.on( o, f );
 	};
 });
 
-jQuery.each( [ "get", "post" ], function( i, method ) {
-	jQuery[ method ] = function( url, data, callback, type ) {
+jqAjax.each( [ "get", "post" ], function( i, method ) {
+	jqAjax[ method ] = function( url, data, callback, type ) {
 		// shift arguments if data argument was omitted
-		if ( jQuery.isFunction( data ) ) {
+		if ( jqAjax.isFunction( data ) ) {
 			type = type || callback;
 			callback = data;
 			data = undefined;
 		}
 
-		return jQuery.ajax({
+		return jqAjax.ajax({
 			type: method,
 			url: url,
 			data: data,
@@ -3224,14 +3215,14 @@
 	};
 });
 
-jQuery.extend({
+jqAjax.extend({
 
 	getScript: function( url, callback ) {
-		return jQuery.get( url, undefined, callback, "script" );
+		return jqAjax.get( url, undefined, callback, "script" );
 	},
 
 	getJSON: function( url, data, callback ) {
-		return jQuery.get( url, data, callback, "json" );
+		return jqAjax.get( url, data, callback, "json" );
 	},
 
 	// Creates a full fledged settings object into target
@@ -3240,11 +3231,11 @@
 	ajaxSetup: function( target, settings ) {
 		if ( settings ) {
 			// Building a settings object
-			ajaxExtend( target, jQuery.ajaxSettings );
+			ajaxExtend( target, jqAjax.ajaxSettings );
 		} else {
 			// Extending ajaxSettings
 			settings = target;
-			target = jQuery.ajaxSettings;
+			target = jqAjax.ajaxSettings;
 		}
 		ajaxExtend( target, settings );
 		return target;
@@ -3301,10 +3292,10 @@
 			"text html": true,
 
 			// Evaluate text as a json expression
-			"text json": jQuery.parseJSON,
+			"text json": jqAjax.parseJSON,
 
 			// Parse text as xml
-			"text xml": jQuery.parseXML
+			"text xml": jqAjax.parseXML
 		},
 
 		// For options that shouldn't be deep extended:
@@ -3348,18 +3339,18 @@
 			// Loop variable
 			i,
 			// Create the final options object
-			s = jQuery.ajaxSetup( {}, options ),
+			s = jqAjax.ajaxSetup( {}, options ),
 			// Callbacks context
 			callbackContext = s.context || s,
 			// Context for global events
 			// It's the callbackContext if one was provided in the options
-			// and if it's a DOM node or a jQuery collection
+			// and if it's a DOM node or a jqAjax collection
 			globalEventContext = callbackContext !== s &&
-				( callbackContext.nodeType || callbackContext instanceof jQuery ) ?
-						jQuery( callbackContext ) : jQuery.event,
+				( callbackContext.nodeType || callbackContext instanceof jqAjax ) ?
+						jqAjax( callbackContext ) : jqAjax.event,
 			// Deferreds
-			deferred = jQuery.Deferred(),
-			completeDeferred = jQuery.Callbacks( "once memory" ),
+			deferred = jqAjax.Deferred(),
+			completeDeferred = jqAjax.Callbacks( "once memory" ),
 			// Status-dependent callbacks
 			statusCode = s.statusCode || {},
 			// Headers (they are sent all at once)
@@ -3466,11 +3457,11 @@
 
 					modified = jqXHR.getResponseHeader("Last-Modified");
 					if ( modified ) {
-						jQuery.lastModified[ ifModifiedKey ] = modified;
+						jqAjax.lastModified[ ifModifiedKey ] = modified;
 					}
 					modified = jqXHR.getResponseHeader("Etag");
 					if ( modified ) {
-						jQuery.etag[ ifModifiedKey ] = modified;
+						jqAjax.etag[ ifModifiedKey ] = modified;
 					}
 				}
 
@@ -3527,8 +3518,8 @@
 			if ( fireGlobals ) {
 				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
 				// Handle the global AJAX counter
-				if ( !( --jQuery.active ) ) {
-					jQuery.event.trigger( "ajaxStop" );
+				if ( !( --jqAjax.active ) ) {
+					jqAjax.event.trigger( "ajaxStop" );
 				}
 			}
 		}
@@ -3561,7 +3552,7 @@
 		s.url = ( ( url || s.url ) + "" ).replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );
 
 		// Extract dataTypes list
-		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().split( core_rspace );
+		s.dataTypes = jqAjax.trim( s.dataType || "*" ).toLowerCase().split( core_rspace );
 
 		// A cross-domain request is in order when we have a protocol:host:port mismatch
 		if ( s.crossDomain == null ) {
@@ -3575,7 +3566,7 @@
 
 		// Convert data if not already a string
 		if ( s.data && s.processData && typeof s.data !== "string" ) {
-			s.data = jQuery.param( s.data, s.traditional );
+			s.data = jqAjax.param( s.data, s.traditional );
 		}
 
 		// Apply prefilters
@@ -3596,8 +3587,8 @@
 		s.hasContent = !rnoContent.test( s.type );
 
 		// Watch for a new set of requests
-		if ( fireGlobals && jQuery.active++ === 0 ) {
-			jQuery.event.trigger( "ajaxStart" );
+		if ( fireGlobals && jqAjax.active++ === 0 ) {
+			jqAjax.event.trigger( "ajaxStart" );
 		}
 
 		// More options handling for requests with no content
@@ -3616,7 +3607,7 @@
 			// Add anti-cache in url if needed
 			if ( s.cache === false ) {
 
-				var ts = jQuery.now(),
+				var ts = jqAjax.now(),
 					// try replacing _= if it is there
 					ret = s.url.replace( rts, "$1_=" + ts );
 
@@ -3633,11 +3624,11 @@
 		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
 		if ( s.ifModified ) {
 			ifModifiedKey = ifModifiedKey || s.url;
-			if ( jQuery.lastModified[ ifModifiedKey ] ) {
-				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ ifModifiedKey ] );
+			if ( jqAjax.lastModified[ ifModifiedKey ] ) {
+				jqXHR.setRequestHeader( "If-Modified-Since", jqAjax.lastModified[ ifModifiedKey ] );
 			}
-			if ( jQuery.etag[ ifModifiedKey ] ) {
-				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ ifModifiedKey ] );
+			if ( jqAjax.etag[ ifModifiedKey ] ) {
+				jqXHR.setRequestHeader( "If-None-Match", jqAjax.etag[ ifModifiedKey ] );
 			}
 		}
 
@@ -3890,7 +3881,7 @@
 
 // Create the request object
 // (This is still attached to ajaxSettings for backward compatibility)
-jQuery.ajaxSettings.xhr = window.ActiveXObject ?
+jqAjax.ajaxSettings.xhr = window.ActiveXObject ?
 	/* Microsoft failed to properly
 	 * implement the XMLHttpRequest in IE7 (can't request local files),
 	 * so we use the ActiveXObject when it is available
@@ -3905,18 +3896,18 @@
 
 // Determine support properties
 (function( xhr ) {
-	jQuery.extend( jQuery.support, {
+	jqAjax.extend( jqAjax.support, {
 		ajax: !!xhr,
 		cors: !!xhr && ( "withCredentials" in xhr )
 	});
-})( jQuery.ajaxSettings.xhr() );
+})( jqAjax.ajaxSettings.xhr() );
 
 // Create transport if the browser can provide an xhr
-if ( jQuery.support.ajax ) {
+if ( jqAjax.support.ajax ) {
 
-	jQuery.ajaxTransport(function( s ) {
+	jqAjax.ajaxTransport(function( s ) {
 		// Cross domain only allowed if supported through XMLHttpRequest
-		if ( !s.crossDomain || jQuery.support.cors ) {
+		if ( !s.crossDomain || jqAjax.support.cors ) {
 
 			var callback;
 
@@ -3965,7 +3956,7 @@
 
 					// Do send the request
 					// This may raise an exception which is actually
-					// handled in jQuery.ajax (so no try/catch here)
+					// handled in jqAjax.ajax (so no try/catch here)
 					xhr.send( ( s.hasContent && s.data ) || null );
 
 					// Listener
@@ -3990,7 +3981,7 @@
 
 								// Do not keep as active anymore
 								if ( handle ) {
-									xhr.onreadystatechange = jQuery.noop;
+									xhr.onreadystatechange = jqAjax.noop;
 									if ( xhrOnUnloadAbort ) {
 										delete xhrCallbacks[ handle ];
 									}
@@ -4068,7 +4059,7 @@
 							// and attach the unload handler
 							if ( !xhrCallbacks ) {
 								xhrCallbacks = {};
-								jQuery( window ).unload( xhrOnUnloadAbort );
+								jqAjax( window ).unload( xhrOnUnloadAbort );
 							}
 							// Add to list of active xhrs callbacks
 							xhrCallbacks[ handle ] = callback;
@@ -4087,7 +4078,7 @@
 	});
 }
 // Install script dataType
-jQuery.ajaxSetup({
+jqAjax.ajaxSetup({
 	accepts: {
 		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
 	},
@@ -4096,14 +4087,14 @@
 	},
 	converters: {
 		"text script": function( text ) {
-			jQuery.globalEval( text );
+			jqAjax.globalEval( text );
 			return text;
 		}
 	}
 });
 
 // Handle cache's special case and global
-jQuery.ajaxPrefilter( "script", function( s ) {
+jqAjax.ajaxPrefilter( "script", function( s ) {
 	if ( s.cache === undefined ) {
 		s.cache = false;
 	}
@@ -4114,7 +4105,7 @@
 });
 
 // Bind script tag hack transport
-jQuery.ajaxTransport( "script", function(s) {
+jqAjax.ajaxTransport( "script", function(s) {
 
 	// This transport only deals with cross domain requests
 	if ( s.crossDomain ) {
@@ -4174,20 +4165,20 @@
 var oldCallbacks = [],
 	rquestion = /\?/,
 	rjsonp = /(=)\?(?=&|$)|\?\?/,
-	nonce = jQuery.now();
+	nonce = jqAjax.now();
 
 // Default jsonp settings
-jQuery.ajaxSetup({
+jqAjax.ajaxSetup({
 	jsonp: "callback",
 	jsonpCallback: function() {
-		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
+		var callback = oldCallbacks.pop() || ( jqAjax.expando + "_" + ( nonce++ ) );
 		this[ callback ] = true;
 		return callback;
 	}
 });
 
 // Detect, normalize options and install callbacks for jsonp requests
-jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {
+jqAjax.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {
 
 	var callbackName, overwritten, responseContainer,
 		data = s.data,
@@ -4202,7 +4193,7 @@
 	if ( s.dataTypes[ 0 ] === "jsonp" || replaceInUrl || replaceInData ) {
 
 		// Get callback name, remembering preexisting value associated with it
-		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
+		callbackName = s.jsonpCallback = jqAjax.isFunction( s.jsonpCallback ) ?
 			s.jsonpCallback() :
 			s.jsonpCallback;
 		overwritten = window[ callbackName ];
@@ -4219,7 +4210,7 @@
 		// Use data converter to retrieve json after script execution
 		s.converters["script json"] = function() {
 			if ( !responseContainer ) {
-				jQuery.error( callbackName + " was not called" );
+				jqAjax.error( callbackName + " was not called" );
 			}
 			return responseContainer[ 0 ];
 		};
@@ -4247,7 +4238,7 @@
 			}
 
 			// Call if it was a function and we have a response
-			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
+			if ( responseContainer && jqAjax.isFunction( overwritten ) ) {
 				overwritten( responseContainer[ 0 ] );
 			}
 
@@ -4258,23 +4249,23 @@
 		return "script";
 	}
 });
-// Expose jQuery to the global object
-window.jQuery = window.$ = jQuery;
+// Expose jqAjax to the global object
+window.jqAjax = jqAjax;
 
-// Expose jQuery as an AMD module, but only for AMD loaders that
-// understand the issues with loading multiple versions of jQuery
+// Expose jqAjax as an AMD module, but only for AMD loaders that
+// understand the issues with loading multiple versions of jqAjax
 // in a page that all might call define(). The loader will indicate
-// they have special allowances for multiple jQuery versions by
-// specifying define.amd.jQuery = true. Register as a named module,
-// since jQuery can be concatenated with other files that may use define,
+// they have special allowances for multiple jqAjax versions by
+// specifying define.amd.jqAjax = true. Register as a named module,
+// since jqAjax can be concatenated with other files that may use define,
 // but not use a proper concatenation script that understands anonymous
 // AMD modules. A named AMD is safest and most robust way to register.
-// Lowercase jquery is used because AMD module names are derived from
-// file names, and jQuery is normally delivered in a lowercase file name.
+// Lowercase jqajax is used because AMD module names are derived from
+// file names, and jqAjax is normally delivered in a lowercase file name.
 // Do this after creating the global so that if an AMD module wants to call
-// noConflict to hide this version of jQuery, it will work.
-if ( typeof define === "function" && define.amd && define.amd.jQuery ) {
-	define( "jquery", [], function () { return jQuery; } );
+// noConflict to hide this version of jqAjax, it will work.
+if ( typeof define === "function" && define.amd && define.amd.jqAjax ) {
+	define( "jqajax", [], function () { return jqAjax; } );
 }
 
 })( window );
